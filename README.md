MyRPC
===============
这个项目是在LInux平台上使用CMake构建项目的编译环境，基于C++语言实现的一个RPC分布式网络通信框架项目。可以把单体架构系统的本地方法调用，重构成基于TCP网络通信的RPC远程方法调用，实现统一台机器不同进程或者不同机器之间的服务调用，适用于把单体架构系统拆分成基于分布式微服务调用进行部署，把并发性能要求大的微服务部署多份，主要用于提升系统并发性能、模块服务独立升级和服务间解耦。

项目描述
===============
> * 使用muduo网络库实现高并发的RPC同步调用请求处理
> * 基于Protobuf实现RPC方法调用和参数的序列化和反序列化
> * 基于ZooKeeper分布式协调服务中间件提供服务注册和服务发现功能
> * 基于线程安全的缓冲队列实现异步日志输出
> * 设计了基于TCP传输的二进制协议，能够高效传输服务名、方法名以及参数
> * RPC服务器通过哈希表维护RPC方法信息，在ZooKeeper中注册含有RPC服务信息的Znode节点。通过Protobuf反序列化服务调用方传输的参数，并将返回参数序列化发送回去

项目使用
===============
> * 当前目录下运行./build.sh即可，会在bin目录下面生成两个已经写好例子的可执行文件
> * 使用**consumer -i test.conf**以及**provider -i test.conf**来加载配置文件，配置文件中主要有server以及zookeeper server的ip地址与端口号
> * 使用protobuf来先注册自己想要提供的Server以及Message，服务器通过继承重写的方式来替换本地方法
> * 客户端通过stub来调用服务器端的提供的方法
> * zookeeper起到了服务注册以及服务发现功能.

项目流程
===============
> * Rpcserver向zookeeper中进行节点的注册，也就是说把服务名和方法名当做键，值就是本地的ip和port。
> * Rpcclient发情Rpc请求之后，首先会连接zookeeper，查询zookeeper中是否有提供相应的rpc服务的节点，如果有这个节点的话，返回来ip地址和端口号
> * 进行通信，发送一个数据序列，这个数据序列包括了Rpc方法需要调用的服务名和方法名。当框架收到这个消息以后，将序列利用protobuf进行一次拆分，判断出来节点需要调用的服务和方法
> * 调用callmethod方法将对应的方法分发下去，同时注册了相应的回调函数，当service完成服务之后，会调用注册好的回调函数OnMessage，通知给框架服务完成
> * 在这个回调函数中就会将请求结果发送回去，Closure* done

为什么使用protobuf
===============
> * json是纯文本操作，protobuf是基于二进制序列化数据的，进行rpc通信时数据占用带宽比json效率要高很多。
> * protobuf原生提供了了基于rpc service方法调用代码框架，封装了很好用的接口，实现rpc方法远程调用非常简单，我们只需要关注服务管理和rpc通信流程的开发。
> * 而json只是一个简单的数据序列化和反序列化协议，没有protobuf这些额外的功能就，所以项目使用了protobuf。

RPC调用协议
===============
> * 格式主要为  **定义header_size（4字节） + header_str + args_str**
> * head_size表示header的长度（这里不是整个字符串的长度），使用二进制发送，四个字节是32位不会超出int的类型，接收方使用二进制流的形式，直接把字符串copy到int中。如果用字符串存储的话长度会非常大。发送方直接取header_size的地址以char*的形式，这样能够直接以二进制的形式存储
> * header_str是使用protobuf定义的rpcHeader Message序列化成字符串，主要有三个成员，service_name、method_name、args_size。主要是服务名，方法名，以及参数字符串的长度，也就是args_str的长度。
> * args_str主要是输入参数，将protobuf定义的request序列化成字符串，主要成员为需要调用方法的参数。